{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = keysOfValidator;\nvar _isPrimitive = _interopRequireDefault(require(\"./helpers/isPrimitive\"));\nvar _wrapValidator = _interopRequireDefault(require(\"./helpers/wrapValidator\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction keysOfValidator(propType) {\n  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'keysOf';\n  if (typeof propType !== 'function') {\n    throw new TypeError('argument to keysOf must be a valid PropType function');\n  }\n  var validator = function keysOf(props, propName, componentName, location, propFullName) {\n    for (var _len = arguments.length, rest = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {\n      rest[_key - 5] = arguments[_key];\n    }\n    var propValue = props[propName];\n    if (propValue == null || (0, _isPrimitive[\"default\"])(propValue)) {\n      return null;\n    }\n    var firstError = null;\n    Object.keys(propValue).some(function (key) {\n      firstError = propType.apply(void 0, [_defineProperty({}, key, key), key, componentName, location, \"(\".concat(propFullName, \").\").concat(key)].concat(rest));\n      return firstError != null;\n    });\n    return firstError || null;\n  };\n  validator.isRequired = function keyedByRequired(props, propName, componentName) {\n    var propValue = props[propName];\n    if (propValue == null) {\n      return new TypeError(\"\".concat(componentName, \": \").concat(propName, \" is required, but value is \").concat(propValue));\n    }\n    for (var _len2 = arguments.length, rest = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n      rest[_key2 - 3] = arguments[_key2];\n    }\n    return validator.apply(void 0, [props, propName, componentName].concat(rest));\n  };\n  return (0, _wrapValidator[\"default\"])(validator, name, propType);\n}","map":{"version":3,"mappings":";;;;;;AAAA;AACA;;;;;;;;;;;;;;;;;;;AAEe,SAASA,eAAT,CAAyBC,QAAzB,EAAoD;EAAA,IAAjBC,IAAiB,uEAAV,QAAU;EACjE,IAAI,OAAOD,QAAP,KAAoB,UAAxB,EAAoC;IAClC,MAAM,IAAIE,SAAJ,CAAc,sDAAd,CAAN;EACD;EAED,IAAMC,SAAS,GAAG,SAASC,MAAT,CAChBC,KADgB,EAEhBC,QAFgB,EAGhBC,aAHgB,EAIhBC,QAJgB,EAKhBC,YALgB,EAOhB;IAAA,kCADGC,IACH;MADGA,IACH;IAAA;IAAA,IACoBC,SADpB,GACkCN,KADlC,CACSC,QADT;IAGA,IAAIK,SAAS,IAAI,IAAb,IAAqB,6BAAYA,SAAZ,CAAzB,EAAiD;MAC/C,OAAO,IAAP;IACD;IAED,IAAIC,UAAU,GAAG,IAAjB;IACAC,MAAM,CAACC,IAAP,CAAYH,SAAZ,EAAuBI,IAAvB,CAA4B,UAACC,GAAD,EAAS;MACnCJ,UAAU,GAAGZ,QAAQ,MAAR,8BACRgB,GADQ,EACFA,GADE,GAEXA,GAFW,EAGXT,aAHW,EAIXC,QAJW,aAKPC,YALO,eAKUO,GALV,UAMRN,IANQ,EAAb;MAQA,OAAOE,UAAU,IAAI,IAArB;IACD,CAVD;IAWA,OAAOA,UAAU,IAAI,IAArB;EACD,CA3BD;EA6BAT,SAAS,CAACc,UAAV,GAAuB,SAASC,eAAT,CAAyBb,KAAzB,EAAgCC,QAAhC,EAA0CC,aAA1C,EAAkE;IAAA,IACnEI,SADmE,GACrDN,KADqD,CAC9EC,QAD8E;IAGvF,IAAIK,SAAS,IAAI,IAAjB,EAAuB;MACrB,OAAO,IAAIT,SAAJ,WAAiBK,aAAjB,eAAmCD,QAAnC,wCAAyEK,SAAzE,EAAP;IACD;IALsF,mCAAND,IAAM;MAANA,IAAM;IAAA;IAOvF,OAAOP,SAAS,MAAT,UAAUE,KAAV,EAAiBC,QAAjB,EAA2BC,aAA3B,SAA6CG,IAA7C,EAAP;EACD,CARD;EAUA,OAAO,+BAAcP,SAAd,EAAyBF,IAAzB,EAA+BD,QAA/B,CAAP;AACD","names":["keysOfValidator","propType","name","TypeError","validator","keysOf","props","propName","componentName","location","propFullName","rest","propValue","firstError","Object","keys","some","key","isRequired","keyedByRequired"],"sources":["/Users/thilakvoruganti/Desktop/FlightBooking/node_modules/airbnb-prop-types/src/keysOf.js"],"sourcesContent":["import isPrimitive from './helpers/isPrimitive';\nimport wrapValidator from './helpers/wrapValidator';\n\nexport default function keysOfValidator(propType, name = 'keysOf') {\n  if (typeof propType !== 'function') {\n    throw new TypeError('argument to keysOf must be a valid PropType function');\n  }\n\n  const validator = function keysOf(\n    props,\n    propName,\n    componentName,\n    location,\n    propFullName,\n    ...rest\n  ) {\n    const { [propName]: propValue } = props;\n\n    if (propValue == null || isPrimitive(propValue)) {\n      return null;\n    }\n\n    let firstError = null;\n    Object.keys(propValue).some((key) => {\n      firstError = propType(\n        { [key]: key },\n        key,\n        componentName,\n        location,\n        `(${propFullName}).${key}`,\n        ...rest,\n      );\n      return firstError != null;\n    });\n    return firstError || null;\n  };\n\n  validator.isRequired = function keyedByRequired(props, propName, componentName, ...rest) {\n    const { [propName]: propValue } = props;\n\n    if (propValue == null) {\n      return new TypeError(`${componentName}: ${propName} is required, but value is ${propValue}`);\n    }\n\n    return validator(props, propName, componentName, ...rest);\n  };\n\n  return wrapValidator(validator, name, propType);\n}\n"]},"metadata":{},"sourceType":"script"}