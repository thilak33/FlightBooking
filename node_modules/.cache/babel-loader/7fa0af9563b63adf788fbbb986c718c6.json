{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar _arrayPrototype = _interopRequireDefault(require(\"array.prototype.find\"));\nvar _getComponentName = _interopRequireDefault(require(\"./helpers/getComponentName\"));\nvar _renderableChildren = _interopRequireDefault(require(\"./helpers/renderableChildren\"));\nvar _wrapValidator = _interopRequireDefault(require(\"./helpers/wrapValidator\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nfunction onlyTypes(types, children, componentName) {\n  if (!children.every(function (child) {\n    return child && (0, _arrayPrototype[\"default\"])(types, function (Type) {\n      return Type === '*' || child.type === Type;\n    });\n  })) {\n    var typeNames = types.map(_getComponentName[\"default\"]).join(', or ');\n    return new TypeError(\"`\".concat(componentName, \"` only accepts children of type \").concat(typeNames));\n  }\n  return null;\n}\nfunction isRequired(types, children, componentName) {\n  if (children.length === 0) {\n    var typeNames = types.map(_getComponentName[\"default\"]).join(', or ');\n    return new TypeError(\"`\".concat(componentName, \"` requires at least one node of type \").concat(typeNames));\n  }\n  return null;\n}\nfunction childrenOfType() {\n  for (var _len = arguments.length, types = new Array(_len), _key = 0; _key < _len; _key++) {\n    types[_key] = arguments[_key];\n  }\n  if (types.length < 1) {\n    throw new TypeError('childrenOfType: at least 1 type is required');\n  }\n  function validator(props, propName, componentName) {\n    return onlyTypes(types, (0, _renderableChildren[\"default\"])(props[propName]), componentName);\n  }\n  validator.isRequired = function (props, propName, componentName) {\n    var children = (0, _renderableChildren[\"default\"])(props[propName]);\n    return isRequired(types, children, componentName) || onlyTypes(types, children, componentName);\n  };\n  return (0, _wrapValidator[\"default\"])(validator, 'childrenOfType', types);\n}\nvar _default = childrenOfType;\nexports[\"default\"] = _default;","map":{"version":3,"mappings":";;;;;;AAAA;AAEA;AACA;AACA;;;;;;AAEA,SAASA,SAAT,CAAmBC,KAAnB,EAA0BC,QAA1B,EAAoCC,aAApC,EAAmD;EACjD,IAAI,CAACD,QAAQ,CAACE,KAAT,CAAe,UAACC,KAAD;IAAA,OAAWA,KAAK,IAAI,gCAAKJ,KAAL,EAAY,UAACK,IAAD;MAAA,OAAUA,IAAI,KAAK,GAAT,IAAgBD,KAAK,CAACE,IAAN,KAAeD,IAAzC;IAAA,CAAZ,CAApB;EAAA,CAAf,CAAL,EAAqG;IACnG,IAAME,SAAS,GAAGP,KAAK,CAACQ,GAAN,CAAUC,4BAAV,EAA4BC,IAA5B,CAAiC,OAAjC,CAAlB;IACA,OAAO,IAAIC,SAAJ,YACAT,aADA,6CACiDK,SADjD,EAAP;EAGD;EACD,OAAO,IAAP;AACD;AAED,SAASK,UAAT,CAAoBZ,KAApB,EAA2BC,QAA3B,EAAqCC,aAArC,EAAoD;EAClD,IAAID,QAAQ,CAACY,MAAT,KAAoB,CAAxB,EAA2B;IACzB,IAAMN,SAAS,GAAGP,KAAK,CAACQ,GAAN,CAAUC,4BAAV,EAA4BC,IAA5B,CAAiC,OAAjC,CAAlB;IACA,OAAO,IAAIC,SAAJ,YAAmBT,aAAnB,kDAAyEK,SAAzE,EAAP;EACD;EACD,OAAO,IAAP;AACD;AAED,SAASO,cAAT,GAAkC;EAAA,kCAAPd,KAAO;IAAPA,KAAO;EAAA;EAChC,IAAIA,KAAK,CAACa,MAAN,GAAe,CAAnB,EAAsB;IACpB,MAAM,IAAIF,SAAJ,CAAc,6CAAd,CAAN;EACD;EAED,SAASI,SAAT,CAAmBC,KAAnB,EAA0BC,QAA1B,EAAoCf,aAApC,EAAmD;IACjD,OAAOH,SAAS,CAACC,KAAD,EAAQ,oCAAmBgB,KAAK,CAACC,QAAD,CAAxB,CAAR,EAA6Cf,aAA7C,CAAhB;EACD;EAEDa,SAAS,CAACH,UAAV,GAAuB,UAACI,KAAD,EAAQC,QAAR,EAAkBf,aAAlB,EAAoC;IACzD,IAAMD,QAAQ,GAAG,oCAAmBe,KAAK,CAACC,QAAD,CAAxB,CAAjB;IACA,OAAOL,UAAU,CAACZ,KAAD,EAAQC,QAAR,EAAkBC,aAAlB,CAAV,IAA8CH,SAAS,CAACC,KAAD,EAAQC,QAAR,EAAkBC,aAAlB,CAA9D;EACD,CAHD;EAKA,OAAO,+BAAca,SAAd,EAAyB,gBAAzB,EAA2Cf,KAA3C,CAAP;AACD;eAEcc,c","names":["onlyTypes","types","children","componentName","every","child","Type","type","typeNames","map","getComponentName","join","TypeError","isRequired","length","childrenOfType","validator","props","propName"],"sources":["/Users/thilakvoruganti/Desktop/FlightBooking/node_modules/airbnb-prop-types/src/childrenOfType.js"],"sourcesContent":["import find from 'array.prototype.find';\n\nimport getComponentName from './helpers/getComponentName';\nimport renderableChildren from './helpers/renderableChildren';\nimport wrapValidator from './helpers/wrapValidator';\n\nfunction onlyTypes(types, children, componentName) {\n  if (!children.every((child) => child && find(types, (Type) => Type === '*' || child.type === Type))) {\n    const typeNames = types.map(getComponentName).join(', or ');\n    return new TypeError(\n      `\\`${componentName}\\` only accepts children of type ${typeNames}`,\n    );\n  }\n  return null;\n}\n\nfunction isRequired(types, children, componentName) {\n  if (children.length === 0) {\n    const typeNames = types.map(getComponentName).join(', or ');\n    return new TypeError(`\\`${componentName}\\` requires at least one node of type ${typeNames}`);\n  }\n  return null;\n}\n\nfunction childrenOfType(...types) {\n  if (types.length < 1) {\n    throw new TypeError('childrenOfType: at least 1 type is required');\n  }\n\n  function validator(props, propName, componentName) {\n    return onlyTypes(types, renderableChildren(props[propName]), componentName);\n  }\n\n  validator.isRequired = (props, propName, componentName) => {\n    const children = renderableChildren(props[propName]);\n    return isRequired(types, children, componentName) || onlyTypes(types, children, componentName);\n  };\n\n  return wrapValidator(validator, 'childrenOfType', types);\n}\n\nexport default childrenOfType;\n"]},"metadata":{},"sourceType":"script"}